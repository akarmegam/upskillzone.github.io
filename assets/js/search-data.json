{"0": {
    "doc": "Add two numbers without using arithmetic operators",
    "title": "Add two numbers without using arithmetic operators",
    "content": "Need to add two number without using arithemetic operators like +, -, *, /, %. ",
    "url": "/Interview-Programs/Add-two-numbers-without-using-arithemetic-operators.html",
    "relUrl": "/Interview-Programs/Add-two-numbers-without-using-arithemetic-operators.html"
  },"1": {
    "doc": "Add two numbers without using arithmetic operators",
    "title": "Solution",
    "content": "Adding two number without using arithmetic operators can be performed using binary operators XOR (^) and AND (&amp;). | First two number is XORed and stored the result in sum variable. sum = num1 ^ num2; . | Then same two number is ANDed and left shifted once and stored the result in carry variable. carry = (num1 &amp; num2) &lt;&lt; 1; . | Then if carry is non zero then continue 1st and 2nd step by keeping sum as first number and carry as second number. | . Here 1st operation performs XOR operation on two numbers and that ommits the carry on every bit. For example XORing two number 6 (110) and 4 (100) gives result as 2 (010), 3rd position generates carry which needs to be placed on 4th position that is not done by X0R. That is why 2nd operation is needed here, that performs AND on the same two number and result is left shifted to get 8 (1000). Now redoing 1st and 2nd operation with first number as 2 and 2nd number as 8 will get 10 as part of 1st operation. And 0 as part of 2nd operation. The execution ends once the 2nd operation (carry generation) returns 0. ",
    "url": "/Interview-Programs/Add-two-numbers-without-using-arithemetic-operators.html#solution",
    "relUrl": "/Interview-Programs/Add-two-numbers-without-using-arithemetic-operators.html#solution"
  },"2": {
    "doc": "Add two numbers without using arithmetic operators",
    "title": "Algorithm Pseudocode",
    "content": "int add(int num1, int num2) { int sum, carry; do { sum = num1 ^ num2; carry = (num1 &amp; num2) &lt;&lt; 1; num1 = sum; num2 = carry; } while (carry != 0); return sum; } . ",
    "url": "/Interview-Programs/Add-two-numbers-without-using-arithemetic-operators.html#algorithm-pseudocode",
    "relUrl": "/Interview-Programs/Add-two-numbers-without-using-arithemetic-operators.html#algorithm-pseudocode"
  },"3": {
    "doc": "Egg Dropping Puzzle - n eggs and m floors",
    "title": "Egg Dropping Puzzle - n eggs and m floors",
    "content": "Given n number of Eggs are identical in dimension and there is a multistorey building with m floors. In this building initial few floors will be safe for Dropping Eggs, which means egg wont break when it is dropped. After that floor, all above floors are unsafe for Egg Dropping. The Puzzle is to find till which number of floors, dropping egg is safest with optimal number of drops ? . | n number of eggs are given. All of the eggs are allowed to break in the process of solving this Puzzle. | Optimial solution for this Puzzle should be with less number of drops. | Don’t try to solve this puzzle by considering Earth’s gravity. Because randomly initial few floors are considered as safest to evaluate the Solution’s optimality. | If the egg does’t break at a certain floor means, it wont break on all the below floors. | Similarly if the egg breaks at a certain floor means, it will break on all the above floors. | . ",
    "url": "/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors.html",
    "relUrl": "/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors.html"
  },"4": {
    "doc": "Egg Dropping Puzzle - n eggs and m floors",
    "title": "Solution",
    "content": "Simplest and unoptimal solution comes to mind immediatly is just take one of the egg and keep dropping from floor 1 to m. Continue this process on each floor till the egg breaks. Once the egg breaks the safest floors are found. Floors below the floor on which it breaks are the safest floors. Above solution is based on Linear traversal, worst case complexity is O(m). To get optimal results, need to pick the floor based on Binary Search (also called as Logarithmic Search). But this has a risk of breaking all eggs before finding the results. So the Optimal Solution can be achieved by combining Binary and Linear Search. | Pick the floors based on Binary Search and drop the egg till the remainings eggs are more than one. | Once the remaining egg is only one, then stop Binary Search and start Linear Search. | . ",
    "url": "/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors.html#solution",
    "relUrl": "/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors.html#solution"
  },"5": {
    "doc": "Egg Dropping Puzzle - n eggs and m floors",
    "title": "Algorithm Pseudocode",
    "content": "uint32_t find_safest_floors(uint32_t n_eggs, uint32_t m_floors) { uint32_t start = 1, floor; uint32_t end = m_floors; do { /* Always start and end points to the unchecked floors */ if (n_eggs &gt; 1) { /* Do binary traversal */ if (end != start) { floor = start + ((end - start) / 2); } else { floor = start; /* This is the last check */ } } else { /* Do linear traversal */ floor = start; } if (check_safe(floor) == 1) { if (floor &lt; end) { /* Checking floor range adjustment */ /* If some more floors are there then point start next to * current floor. */ start = floor + 1; } else { /* else we found it */ return floor; } } else { if (n_eggs &gt; 1) { /* If we are in binary traversal */ n_eggs--; /* Reduce egg count, as one egg is broken */ if (floor &gt; start) { /* Checking floor range adjustment */ /* If current checking floor is greater than start then * assign (floor - 1) to end. */ end = floor - 1; } else { /* else we found it */ return (floor - 1); } } else { /* else in linear traversal */ /* Found it */ return (floor - 1); } } } while (1); } . ",
    "url": "/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors.html#algorithm-pseudocode",
    "relUrl": "/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors.html#algorithm-pseudocode"
  },"6": {
    "doc": "Egg Dropping Puzzle - n eggs and m floors",
    "title": "Complete Implementation in C Language",
    "content": "#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;getopt.h&gt; #include &lt;stdlib.h&gt; enum enum_opt { OPT_HELP = 1, OPT_EGGS, OPT_FLOORS, OPT_SAFE_FLOOR }; struct option lopts[] = { {\"help\", no_argument, NULL, OPT_HELP}, {\"eggs\", required_argument, NULL, OPT_EGGS}, {\"floors\", required_argument, NULL, OPT_FLOORS}, {\"safe-floor\", required_argument, NULL, OPT_SAFE_FLOOR}, }; void help() { printf(\"Program to perform optimized checks to find which floor is safest\\n\"); printf(\"among m floors, when eggs are dropped.\\n\"); printf(\"This program takes input as n eggs, m floors, and safe floor\\n\"); printf(\"By using these inputs the program gives output as how many\\n\"); printf(\"minimum checks are needed to find the safe floor\\n\"); printf(\"\\nUsage:\\n\"); printf(\"&lt;exe&gt; --eggs &lt;count&gt; --floors &lt;count&gt; --safe-floor &lt;floor-num&gt;\\n\"); exit(0); } uint32_t m_floors, n_eggs, safe_floor; uint32_t num_of_checks = 0; int check_safe(uint32_t floor) { num_of_checks++; if (floor &lt;= safe_floor) return 1; return 0; } uint32_t find_safest_floors(uint32_t n_eggs, uint32_t m_floors) { uint32_t start = 1, floor; uint32_t end = m_floors; printf(\"%u eggs and %u floors\\n\", n_eggs, m_floors); do { printf(\"Check among floors between %u and %u with %u eggs\\n\", start, end, n_eggs); /* Always start and end points to the unchecked floors */ if (n_eggs &gt; 1) { printf(\" - Doing binary traversal\\n\"); /* Do binary traversal */ if (end != start) { floor = start + ((end - start) / 2); } else { floor = start; /* This is the last check */ } } else { printf(\" - Doing linear traversal\\n\"); /* Do linear traversal */ floor = start; /* TODO Need to add max check */ } printf(\" - Checking floor %u\\n\", floor); if (check_safe(floor) == 1) { printf(\" - %u is safe floor\\n\", floor); if (floor &lt; end) { /* Checking floor range adjustment */ /* If some more floors are there then point start next to * current floor. */ start = floor + 1; } else { /* else we found it */ return floor; } } else { printf(\" - %u is unsafe floor\\n\", floor); if (n_eggs &gt; 1) { /* If we are in binary traversal */ n_eggs--; /* Reduce egg count, as one egg is broken */ if (floor &gt; start) { /* Checking floor range adjustment */ /* If current checking floor is greater than start then * assign (floor - 1) to end. */ end = floor - 1; } else { /* else we found it */ return (floor - 1); } } else { /* else in linear traversal */ /* Found it */ return (floor - 1); } } } while (1); } int main(int argc, char *argv[]) { uint32_t floor; int opt; while ((opt = getopt_long(argc, argv, \"\", lopts, NULL)) != -1) { switch (opt) { case OPT_EGGS: n_eggs = atoi(optarg); break; case OPT_FLOORS: m_floors = atoi(optarg); break; case OPT_SAFE_FLOOR: safe_floor = atoi(optarg); break; case OPT_HELP: default: help(); } } if ((n_eggs == 0) || (m_floors == 0)) { printf(\"Invalid eggs(%u) or floors(%u)\\n\", n_eggs, m_floors); return -1; } floor = find_safest_floors(n_eggs, m_floors); printf(\"It took %u checks to find safest floor %u out of %u floors with %u \" \\ \"eggs\\n\", num_of_checks, floor, m_floors, n_eggs); return 0; } . ",
    "url": "/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors.html#complete-implementation-in-c-language",
    "relUrl": "/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors.html#complete-implementation-in-c-language"
  },"7": {
    "doc": "Egg Dropping Puzzle - n eggs and m floors",
    "title": "Output",
    "content": ". | Below is the operation of the algorithm for 10 floors and 5 eggs with the safest floor 4. | . $ ./a.out --eggs 5 --floors 10 --safe-floor 4 5 eggs and 10 floors Check among floors between 1 and 10 with 5 eggs - Doing binary traversal - Checking floor 5 - 5 is unsafe floor Check among floors between 1 and 4 with 4 eggs - Doing binary traversal - Checking floor 2 - 2 is safe floor Check among floors between 3 and 4 with 4 eggs - Doing binary traversal - Checking floor 3 - 3 is safe floor Check among floors between 4 and 4 with 4 eggs - Doing binary traversal - Checking floor 4 - 4 is safe floor It took 4 checks to find safest floor 4 out of 10 floors with 5 eggs . | Below is the operation of the algorithm for 10 floors and 2 eggs with the safest floor 4. | . $ ./a.out --eggs 2 --floors 10 --safe-floor 4 2 eggs and 10 floors Check among floors between 1 and 10 with 2 eggs - Doing binary traversal - Checking floor 5 - 5 is unsafe floor Check among floors between 1 and 4 with 1 eggs - Doing linear traversal - Checking floor 1 - 1 is safe floor Check among floors between 2 and 4 with 1 eggs - Doing linear traversal - Checking floor 2 - 2 is safe floor Check among floors between 3 and 4 with 1 eggs - Doing linear traversal - Checking floor 3 - 3 is safe floor Check among floors between 4 and 4 with 1 eggs - Doing linear traversal - Checking floor 4 - 4 is safe floor It took 5 checks to find safest floor 4 out of 10 floors with 2 eggs . ",
    "url": "/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors.html#output",
    "relUrl": "/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors.html#output"
  },"8": {
    "doc": "Interview Programs",
    "title": "Interview Programs",
    "content": "Brain teaser questions of Software Program in an Interview is given below. This is one of the first step done by an interviewer to check coding skills of a candidate. ",
    "url": "/Interview-Programs/",
    "relUrl": "/Interview-Programs/"
  },"9": {
    "doc": "Interview Puzzles",
    "title": "Interview Puzzles",
    "content": "Puzzles are one of the important portion in an Software Programmer Interview process to test Interviewee’s Analytical and Problem Skills. And also to test how Interviewee can write an Optimal Code to solve it. Here some of the Puzzles are listed with a Detailed Solution and an Implemention in C language. Don’t believe that one of the below listed Puzzles will appear in your Interview Process. Going through this will help you to improve your skills to approach and solve the Puzzles, that will help to solve any kind of Puzzles in your Interview. All the best for your Hunting process of Software Programming Job. ",
    "url": "/Interview-Puzzles/",
    "relUrl": "/Interview-Puzzles/"
  },"10": {
    "doc": "Home",
    "title": "Home",
    "content": "Up skill zone is a Software Programmer’s zone to upskill the Puzzle solving and Problem solving skills to crack any kind of interviews. And also helps interviewer to assess candidate’s skill with tough and challenging Programming questions. Programming and Problem solving skills are the one which is achieved by constant practising with good set of programming questions. Come to upskillzone.com and practice coding and deliver best in interviews. Best wishes for Job or Interviewee hunting !!! . ",
    "url": "/",
    "relUrl": "/"
  }
}
