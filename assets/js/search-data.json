{"0": {
    "doc": "Home",
    "title": "Home",
    "content": "Up skill zone is a Software Programmer’s zone to upskill the Coding Skills to solve Complex Problems and Puzzles for cracking any kind of interviews. And it also helps interviewer to assess candidate’s skill with tough and challenging questions. Coding and Problem solving skills are the one which is achieved by constant practising with good set of programming questions. Come to upskillzone.com and practice coding and deliver the best in interviews. Best wishes for Job or Interviewee hunting !!! . ",
    "url": "https://upskillzone.com/",
    "relUrl": "/"
  },"1": {
    "doc": "Add two numbers without using arithmetic operators",
    "title": "Add two numbers without using arithmetic operators",
    "content": "Need to add two number without using arithemetic operators like +, -, *, /, %. ",
    "url": "https://upskillzone.com/Interview-Programs/Add-two-numbers-without-using-arithemetic-operators/",
    "relUrl": "/Interview-Programs/Add-two-numbers-without-using-arithemetic-operators/"
  },"2": {
    "doc": "Add two numbers without using arithmetic operators",
    "title": "1. Solution",
    "content": "Adding two number without using arithmetic operators can be performed using binary operators XOR (^) and AND (&amp;). | First two number is XORed and stored the result in sum variable. sum = num1 ^ num2; . | Then same two number is ANDed and left shifted once and stored the result in carry variable. carry = (num1 &amp; num2) &lt;&lt; 1; . | Then if carry is non zero then continue 1st and 2nd step by keeping sum as first number and carry as second number. | . Here 1st operation performs XOR operation on two numbers and that ommits the carry on every bit. For example XORing two number 6 (110) and 4 (100) gives result as 2 (010), 3rd position generates carry which needs to be placed on 4th position that is not done by X0R. That is why 2nd operation is needed here, that performs AND on the same two number and result is left shifted to get 8 (1000). Now redoing 1st and 2nd operation with first number as 2 and 2nd number as 8 will get 10 as part of 1st operation. And 0 as part of 2nd operation. The execution ends once the 2nd operation (carry generation) returns 0. ",
    "url": "https://upskillzone.com/Interview-Programs/Add-two-numbers-without-using-arithemetic-operators/#1-solution",
    "relUrl": "/Interview-Programs/Add-two-numbers-without-using-arithemetic-operators/#1-solution"
  },"3": {
    "doc": "Add two numbers without using arithmetic operators",
    "title": "2. Algorithm Pseudocode",
    "content": "int add(int num1, int num2) { int sum, carry; do { sum = num1 ^ num2; carry = (num1 &amp; num2) &lt;&lt; 1; num1 = sum; num2 = carry; } while (carry != 0); return sum; } . ",
    "url": "https://upskillzone.com/Interview-Programs/Add-two-numbers-without-using-arithemetic-operators/#2-algorithm-pseudocode",
    "relUrl": "/Interview-Programs/Add-two-numbers-without-using-arithemetic-operators/#2-algorithm-pseudocode"
  },"4": {
    "doc": "Interview Programs",
    "title": "Interview Programs",
    "content": "Brain teaser questions of Software Program in an Interview is given below. This is one of the basic step done by an interviewer to check coding skills of a candidate. ",
    "url": "https://upskillzone.com/Interview-Programs/",
    "relUrl": "/Interview-Programs/"
  },"5": {
    "doc": "Swap two numbers without using temporary variable",
    "title": "Swap two numbers without using temporary variable",
    "content": "Swapping two numbers need a temporary variable like mentioned below. tmp = num1; num1 = num2; num2 = tmp; . Can we achieve swapping of two numbers without using temporary variable ? . ",
    "url": "https://upskillzone.com/Interview-Programs/Swap-two-numbers-without-using-temporary-variable/",
    "relUrl": "/Interview-Programs/Swap-two-numbers-without-using-temporary-variable/"
  },"6": {
    "doc": "Swap two numbers without using temporary variable",
    "title": "1. Solution",
    "content": "This can be achieved using three methods which are described below. 1.1 Solution with addition and subtraction operation . | First add both the numbers and store in num1 variable itself. | Then subtract num2 from num1 and store the result on num2. Now num2 gets the value of num1. | Similarly subtract num2 from num1 and store the result on num1. num1 = num1 + num2; num2 = num1 - num2; num1 = num1 - num2; . | . | Here the assumption is, the addition of two number does not overflow. If overflows this is not the right solution. | . 1.2 Solution with multiplication and division operation . Similarly swapping of two numbers can be achieved using multiplication and division. num1 = num1 * num2; num2 = num1 / num2; num1 = num1 / num2; . | This solution is also not suitable if multiplication of two number overflows. | . 1.3 Solution with XOR operation . Solution with XOR operation is the best solution if above 2 solution applicability fails due to overflow. Consider two number as 7 (111) and 5 (101). | First XOR both number and store the result 2 (010) in num1. | Then XOR num1 and num2 and store the result 7 (111) in num2. | Then XOR num1 and num2 and store the result 5 (101) in num1. Swapping is done ! | . num1 = num1 ^ num2; num2 = num1 ^ num2; num1 = num1 ^ num2; . ",
    "url": "https://upskillzone.com/Interview-Programs/Swap-two-numbers-without-using-temporary-variable/#1-solution",
    "relUrl": "/Interview-Programs/Swap-two-numbers-without-using-temporary-variable/#1-solution"
  },"7": {
    "doc": "100 Monkeys and Doors Puzzle",
    "title": "100 Monkeys and Doors Puzzle",
    "content": "There are 100 doors in a row, all of them are initially in closed state. And there are 100 monkeys (or 100 People) as well. All monkeys walks through all the doors one by one. Each monkey toggles the door (that means, closing if the door is opened or opening if the door is closed) while walking through the doors. This toggling on door is performed by monkeys in below mentioned order. | 1st monkey toggles all the doors. | 2nd monkey toggles 2nd, 4th, 6th, … 100th door. | 3rd monkey toggles 3rd, 6th, 9th, … 99th door. | 4th monkey toggles 4th, 8th, 12th, … 100th door. | … | 50th monkey toggles 50th and 100th door. | 100th monkey toggles only 100th door. | . Puzzle is to find out which all doors are opened at the end after all the monkeys walkthrough the doors ? . ",
    "url": "https://upskillzone.com/Interview-Puzzles/100-Monkeys-and-Doors-Puzzle/",
    "relUrl": "/Interview-Puzzles/100-Monkeys-and-Doors-Puzzle/"
  },"8": {
    "doc": "100 Monkeys and Doors Puzzle",
    "title": "1. Solution",
    "content": "Here the initial state of door is closed, so if a door is toggled two times then it will be in closed state. That means for even number of toggles the door state will be closed. Similarly for odd number of toggles the door state will be opened. So need to find which all doors are toggled by monkey in odd number of times. 1.1 Understanding Factors of Number . A door is toggled by ith monkey if i divides door number. So need to understand factors of a number concept here. Factors of a number are a set of numbers which all can divides an another number evenly. For example Factors of 10 are 1, 2, 5, 10. That means, there are four factors for the number 10, all four of them can divide number 10 evenly. These four numbers are factors of 10. This number of factors varies for different numbers. For example number 20 has 6 factors which are 1, 2, 4, 5, 10, 20. All numbers has a minimum of two factors, one of them is 1 and the another is the same number itself. And all prime numbers has only these two as factors, no other factors. Because it is not divisible by any other number, thats why it is called as Prime number. These factors are always occurs as pair. For example take the factors of the number 20, . | 1 x 20 = 20: So both 1 and 20 are factors of 20. | 2 x 10 = 20: So both 2 and 10 are factors of 20. | 4 x 5 = 20: So both 4 and 5 are factors of 20. | . As these factors are occuring in pairs, total number of factors for a numbers are always even except for perfect squares. Perfect squares (1, 4, 9, 16 …) are the one which has odd number of factors. Because perfect squares are the one which results to a multiplication of two same numbers. For example factors of 16 are 1, 2, 4, 8, 16. | 1 x 16 = 16: So both 1 and 16 are factors of 16. | 2 x 8 = 16: So both 2 and 8 are factors of 16. | 4 x 4 = 16: So 4 is factor of 16. No duplicate in the list of factors. | . So all perfect square numbers (1, 4, 9, 16, …) has odd number of factors. 1.2 Using Factors of Number to solve 100 Doors Puzzle . In 100 Door Puzzle, each monkey toggles the door if the door number is divisible by monkey number. That means every door is toggled for the factors of that door number. That means door number 10 is toggled by 4 times, by the 1st, 2nd, 5th and 10th monkeys. Similarly door number 20 is toggled by 6 times. So to find out which all doors are opened after all the monkeys walk through, need to find out which all doors are toggled in odd number of times. As odd number of factors are available only for perfect square numbers, only perfect square number doors (1, 4, 9, 16, … 81) are toggled odd number of times. So these doors are opened at the end. All other doors (2, 3, 5, … 100) are closed at the end. ",
    "url": "https://upskillzone.com/Interview-Puzzles/100-Monkeys-and-Doors-Puzzle/#1-solution",
    "relUrl": "/Interview-Puzzles/100-Monkeys-and-Doors-Puzzle/#1-solution"
  },"9": {
    "doc": "Crossing the Bridge with Torch Puzzle",
    "title": "Crossing the Bridge with Torch Puzzle",
    "content": "Few people are trying to cross an old and rusty bridge in a night. Conditions for crossing the bridge are . | Only 2 person can be on the bridge at a time. | Crossing without torch is impossible. | Each person takes different time to cross the bridge, because of different age groups of people. So when 2 person crosses, faster walking person also should walk equally to the slower walking person. So that both can walk on torch light. | . Puzzle is to find, what is the shortest duration taken by all the people to cross the bridge? . ",
    "url": "https://upskillzone.com/Interview-Puzzles/Crossing-the-Bridge-with-Torch-Puzzle/",
    "relUrl": "/Interview-Puzzles/Crossing-the-Bridge-with-Torch-Puzzle/"
  },"10": {
    "doc": "Crossing the Bridge with Torch Puzzle",
    "title": "1. Solution",
    "content": "Solution is to keep moving 2 people at a time with a torch in multiple batches. After every movement, a fastest walking person who reached the destination should come back to the starting place with the torch so that remaining people can cross. 1.1 Solution with Example . Here the solution is explained with an example. Consider four people are crossing the bridge and their time taken to cross the bridge are given below. | Person A takes 1 min | Person B takes 2 mins | Person C takes 6 mins | Person D takes 10 mins | . The solution to cross the bridge with above set of 4 people are . | First find out two fastest walking person and move them. That means move A and B. This takes 2 mins. | Now C and D are in starting place. A and B are in destination with torch. Now bring back the torch with the help of fastest walking person on the desitnation. That means, make A to bring back the torch. This takes 1 min. | Now A, C and D are in starting place with torch. B is in destination. Now move 2 slowest walking person C and D to the destination. This takes 10 mins. | Now bring back torch with the help of fastest walking person B. This takes 2 mins. | Now move both A and B. This takes 2 mins. | . Now all of them have crossed the bridge with 5 movement. Totally it takes 17mins. 1.2 General Solution . In this puzzle number of person varies, not always with 4 person. So solution to solve with any number of person need to follow below procedure. | Move two fastest person. | If some more are waiting in the starting place, then bring back one fastest person to starting place. Or else finished. | Move two slowest person. | If some more are waiting in the staring place, then bring back the one fastest person to starting place. This person is nothing but the person who moved in Step 2. Or else finished. | Now people who are in destination are slowest person, at this time need to continue from Step1 to move two fastest person. Now moving slowest person is not correct, because next time it will take more time to bring back torch. | . Repeatedly doing above mentioned steps will solve the puzzle with any number of persons. Solution ends either at the Step2 or Step4 when there are no person in the starting place. ",
    "url": "https://upskillzone.com/Interview-Puzzles/Crossing-the-Bridge-with-Torch-Puzzle/#1-solution",
    "relUrl": "/Interview-Puzzles/Crossing-the-Bridge-with-Torch-Puzzle/#1-solution"
  },"11": {
    "doc": "Egg Dropping Puzzle - n eggs and m floors",
    "title": "Egg Dropping Puzzle - n eggs and m floors",
    "content": "Given n number of Eggs are identical in dimension and there is a multistorey building with m floors. In that building only initial few floors will be safe for Dropping Eggs, which means egg wont break when it is dropped. After that all above floors are unsafe for Egg Dropping. The Puzzle is to find till which number of floors, dropping egg is safest with optimal number of tries (dropping eggs) ? . | n number of eggs are given. All of the eggs are allowed to break in the process of solving this Puzzle. | Optimial solution for this Puzzle should be with less number of drops. | Don’t try to solve this puzzle by considering Earth’s gravity. Because randomly initial few floors are considered as safest to evaluate the Solution’s optimality. | If the egg does’t break at a certain floor means, it wont break on all the below floors. | Similarly if the egg breaks at a certain floor means, it will break on all the above floors. | The eggs that are not broken on a drop can be reused to drop on another attempt. | . ",
    "url": "https://upskillzone.com/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors/",
    "relUrl": "/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors/"
  },"12": {
    "doc": "Egg Dropping Puzzle - n eggs and m floors",
    "title": "1. Solution",
    "content": "Simplest and unoptimal solution comes to mind immediatly is just take one of the egg and keep dropping from floor 1 to m. Continue this process on each floor till the egg breaks. Once the egg breaks the safest floors are found. Floors below the floor on which it breaks are the safest floors. Above solution is based on Linear traversal, worst case complexity is O(m). To get optimal results, need to pick the floor based on Binary Search (also called as Logarithmic Search). But this has a risk of breaking all eggs before finding the results. So the Optimal Solution can be achieved by combining both Binary and Linear Search. | Pick the floors based on Binary Search and drop the egg till the remainings eggs are more than one. | Once the remaining egg is only one, then stop Binary Search and start Linear Search. | . 1.2 Detailed Solution explanation with Youtube Video . | In below Youtube video, I have explained this puzzle solution with examples. | . ",
    "url": "https://upskillzone.com/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors/#1-solution",
    "relUrl": "/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors/#1-solution"
  },"13": {
    "doc": "Egg Dropping Puzzle - n eggs and m floors",
    "title": "2. Algorithm Pseudocode",
    "content": ". | Algorithm pseudocode for the above explained solution is given below. | . uint32_t find_safest_floors(uint32_t n_eggs, uint32_t m_floors) { uint32_t start = 1, floor; uint32_t end = m_floors; do { /* Always start and end points to the unchecked floors */ if (n_eggs &gt; 1) { /* Do binary traversal */ if (end != start) { floor = start + ((end - start) / 2); } else { floor = start; /* This is the last check */ } } else { /* Do linear traversal */ floor = start; } if (check_safe(floor) == 1) { if (floor &lt; end) { /* Checking floor range adjustment */ /* If some more floors are there then point start next to * current floor. */ start = floor + 1; } else { /* else we found it */ return floor; } } else { if (n_eggs &gt; 1) { /* If we are in binary traversal */ n_eggs--; /* Reduce egg count, as one egg is broken */ if (floor &gt; start) { /* Checking floor range adjustment */ /* If current checking floor is greater than start then * assign (floor - 1) to end. */ end = floor - 1; } else { /* else we found it */ return (floor - 1); } } else { /* else in linear traversal */ /* Found it */ return (floor - 1); } } } while (1); } . ",
    "url": "https://upskillzone.com/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors/#2-algorithm-pseudocode",
    "relUrl": "/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors/#2-algorithm-pseudocode"
  },"14": {
    "doc": "Egg Dropping Puzzle - n eggs and m floors",
    "title": "3. Complete Implementation in C Language",
    "content": "#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;getopt.h&gt; #include &lt;stdlib.h&gt; enum enum_opt { OPT_HELP = 1, OPT_EGGS, OPT_FLOORS, OPT_SAFE_FLOOR }; struct option lopts[] = { {\"help\", no_argument, NULL, OPT_HELP}, {\"eggs\", required_argument, NULL, OPT_EGGS}, {\"floors\", required_argument, NULL, OPT_FLOORS}, {\"safe-floor\", required_argument, NULL, OPT_SAFE_FLOOR}, }; void help() { printf(\"Program to perform optimized checks to find which floor is safest\\n\"); printf(\"among m floors, when eggs are dropped.\\n\"); printf(\"This program takes input as n eggs, m floors, and safe floor\\n\"); printf(\"By using these inputs the program gives output as how many\\n\"); printf(\"minimum checks are needed to find the safe floor\\n\"); printf(\"\\nUsage:\\n\"); printf(\"&lt;exe&gt; --eggs &lt;count&gt; --floors &lt;count&gt; --safe-floor &lt;floor-num&gt;\\n\"); exit(0); } uint32_t m_floors, n_eggs, safe_floor; uint32_t num_of_checks = 0; int check_safe(uint32_t floor) { num_of_checks++; if (floor &lt;= safe_floor) return 1; return 0; } uint32_t find_safest_floors(uint32_t n_eggs, uint32_t m_floors) { uint32_t start = 1, floor; uint32_t end = m_floors; printf(\"%u eggs and %u floors\\n\", n_eggs, m_floors); do { printf(\"Check among floors between %u and %u with %u eggs\\n\", start, end, n_eggs); /* Always start and end points to the unchecked floors */ if (n_eggs &gt; 1) { printf(\" - Doing binary traversal\\n\"); /* Do binary traversal */ if (end != start) { floor = start + ((end - start) / 2); } else { floor = start; /* This is the last check */ } } else { printf(\" - Doing linear traversal\\n\"); /* Do linear traversal */ floor = start; /* TODO Need to add max check */ } printf(\" - Checking floor %u\\n\", floor); if (check_safe(floor) == 1) { printf(\" - %u is safe floor\\n\", floor); if (floor &lt; end) { /* Checking floor range adjustment */ /* If some more floors are there then point start next to * current floor. */ start = floor + 1; } else { /* else we found it */ return floor; } } else { printf(\" - %u is unsafe floor\\n\", floor); if (n_eggs &gt; 1) { /* If we are in binary traversal */ n_eggs--; /* Reduce egg count, as one egg is broken */ if (floor &gt; start) { /* Checking floor range adjustment */ /* If current checking floor is greater than start then * assign (floor - 1) to end. */ end = floor - 1; } else { /* else we found it */ return (floor - 1); } } else { /* else in linear traversal */ /* Found it */ return (floor - 1); } } } while (1); } int main(int argc, char *argv[]) { uint32_t floor; int opt; while ((opt = getopt_long(argc, argv, \"\", lopts, NULL)) != -1) { switch (opt) { case OPT_EGGS: n_eggs = atoi(optarg); break; case OPT_FLOORS: m_floors = atoi(optarg); break; case OPT_SAFE_FLOOR: safe_floor = atoi(optarg); break; case OPT_HELP: default: help(); } } if ((n_eggs == 0) || (m_floors == 0)) { printf(\"Invalid eggs(%u) or floors(%u)\\n\", n_eggs, m_floors); return -1; } floor = find_safest_floors(n_eggs, m_floors); printf(\"It took %u checks to find safest floor %u out of %u floors with %u \" \\ \"eggs\\n\", num_of_checks, floor, m_floors, n_eggs); return 0; } . ",
    "url": "https://upskillzone.com/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors/#3-complete-implementation-in-c-language",
    "relUrl": "/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors/#3-complete-implementation-in-c-language"
  },"15": {
    "doc": "Egg Dropping Puzzle - n eggs and m floors",
    "title": "4. Output",
    "content": ". | Below is the operation of the algorithm for 10 floors and 5 eggs with the safest floor 4. | . $ ./a.out --eggs 5 --floors 10 --safe-floor 4 5 eggs and 10 floors Check among floors between 1 and 10 with 5 eggs - Doing binary traversal - Checking floor 5 - 5 is unsafe floor Check among floors between 1 and 4 with 4 eggs - Doing binary traversal - Checking floor 2 - 2 is safe floor Check among floors between 3 and 4 with 4 eggs - Doing binary traversal - Checking floor 3 - 3 is safe floor Check among floors between 4 and 4 with 4 eggs - Doing binary traversal - Checking floor 4 - 4 is safe floor It took 4 checks to find safest floor 4 out of 10 floors with 5 eggs . | Below is the operation of the algorithm for 10 floors and 2 eggs with the safest floor 4. | . $ ./a.out --eggs 2 --floors 10 --safe-floor 4 2 eggs and 10 floors Check among floors between 1 and 10 with 2 eggs - Doing binary traversal - Checking floor 5 - 5 is unsafe floor Check among floors between 1 and 4 with 1 eggs - Doing linear traversal - Checking floor 1 - 1 is safe floor Check among floors between 2 and 4 with 1 eggs - Doing linear traversal - Checking floor 2 - 2 is safe floor Check among floors between 3 and 4 with 1 eggs - Doing linear traversal - Checking floor 3 - 3 is safe floor Check among floors between 4 and 4 with 1 eggs - Doing linear traversal - Checking floor 4 - 4 is safe floor It took 5 checks to find safest floor 4 out of 10 floors with 2 eggs . Above program is archived in the github repo with detailed explanation of how to use it. ",
    "url": "https://upskillzone.com/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors/#4-output",
    "relUrl": "/Interview-Puzzles/Egg-Dropping-Puzzle-n-eggs-and-m-floors/#4-output"
  },"16": {
    "doc": "Interview Puzzles",
    "title": "Interview Puzzles",
    "content": "Puzzles are one of the important portion in an Software Programmer Interview process to test Interviewee’s Analytical and Problem Skills. And also to test how Interviewee can write an Optimal Code to solve it. Here some of the Puzzles are listed with a Detailed Solution and an Implemention in C language. Don’t believe that one of the below listed Puzzles will appear in your Interview Process. Going through this will help you to improve your skills to approach and solve the Puzzles, that will help to solve any kind of Puzzles in your Interview. All the best for your Hunting process of Software Programming Job. ",
    "url": "https://upskillzone.com/Interview-Puzzles/",
    "relUrl": "/Interview-Puzzles/"
  }
}
